<!-- Generated by Copilot July 26, 2025 -->
<template>
  <div v-if="isVisible" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50">
    <div class="w-full h-full max-w-6xl max-h-screen p-4">
      <div class="bg-black rounded-lg overflow-hidden h-full flex flex-col">
        <!-- Header -->
        <div class="flex justify-between items-center p-4 bg-gray-800">
          <h3 class="text-white text-lg font-semibold">
            {{ torrentName || 'Torrent Player' }}
          </h3>
          <button 
            @click="closePlayer"
            class="text-white hover:text-red-400 text-2xl"
          >
            ×
          </button>
        </div>
        
        <!-- Loading State -->
        <div v-if="isLoading" class="flex-1 flex items-center justify-center">
          <div class="text-center text-white">
            <div class="loading loading-spinner loading-lg text-red-600 mb-4"></div>
            <p class="text-lg mb-2">{{ loadingText }}</p>
            <div v-if="progress > 0" class="w-64 bg-gray-700 rounded-full h-2">
              <div class="bg-red-600 h-2 rounded-full transition-all duration-300" 
                   :style="`width: ${progress}%`"></div>
            </div>
            <p v-if="downloadSpeed" class="text-sm text-gray-400 mt-2">
              {{ downloadSpeed }}
            </p>
          </div>
        </div>
        
        <!-- Error State -->
        <div v-else-if="error" class="flex-1 flex items-center justify-center">
          <div class="text-center text-white max-w-md">
            <div class="text-red-500 text-6xl mb-4">⚠️</div>
            <h3 class="text-lg font-semibold text-red-400 mb-2">Error</h3>
            <p class="text-gray-300 mb-4">{{ error }}</p>
            <button 
              @click="closePlayer"
              class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded"
            >
              Close
            </button>
          </div>
        </div>
        
        <!-- File Selection -->
        <div v-else-if="videoFiles.length > 1" class="p-4 bg-gray-700">
          <select 
            v-model="selectedFileIndex"
            @change="selectFile"
            class="bg-gray-600 text-white p-2 rounded w-full"
          >
            <option value="" disabled>Select a video file to play</option>
            <option v-for="(file, index) in videoFiles" :key="index" :value="index">
              {{ file.name }} ({{ formatFileSize(file.length) }})
            </option>
          </select>
        </div>
        
        <!-- Video Player -->
        <div v-else-if="selectedFile && videoUrl" class="flex-1 flex items-center justify-center">
          <video 
            ref="videoElement"
            :src="videoUrl"
            class="max-w-full max-h-full"
            controls
            autoplay
            @loadstart="onVideoLoadStart"
            @canplay="onVideoCanPlay"
            @error="onVideoError"
          />
        </div>
        
        <!-- Torrent Info -->
        <div v-if="torrent && !isLoading" class="p-4 bg-gray-800 text-white text-sm">
          <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div>
              <span class="text-gray-400">Peers:</span> {{ torrent.numPeers }}
            </div>
            <div>
              <span class="text-gray-400">Downloaded:</span> {{ formatFileSize(torrent.downloaded) }}
            </div>
            <div>
              <span class="text-gray-400">Upload Speed:</span> {{ formatSpeed(torrent.uploadSpeed) }}
            </div>
            <div>
              <span class="text-gray-400">Download Speed:</span> {{ formatSpeed(torrent.downloadSpeed) }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
// Generated by Copilot July 26, 2025

// WebTorrent types
interface TorrentFile {
  name: string
  length: number
  renderTo(elem: HTMLVideoElement, options?: any, callback?: (err: Error | null) => void): void
}

interface TorrentInstance {
  name: string
  files: TorrentFile[]
  numPeers: number
  downloaded: number
  length: number
  uploadSpeed: number
  downloadSpeed: number
  on(event: string, callback: (...args: any[]) => void): void
}

interface WebTorrentClient {
  new(): WebTorrentClient
  add(magnetUri: string, options?: any): TorrentInstance
  destroy(): void
}

// Extend window interface for WebTorrent
declare global {
  interface Window {
    WebTorrent: WebTorrentClient
  }
}

interface Props {
  magnetUri: string
  isVisible: boolean
}

const props = defineProps<Props>()
const emit = defineEmits<{
  close: []
}>()

const client = ref<WebTorrentClient | null>(null)
const torrent = ref<TorrentInstance | null>(null)
const videoFiles = ref<TorrentFile[]>([])
const selectedFile = ref<TorrentFile | null>(null)
const selectedFileIndex = ref<number | string>('')
const videoUrl = ref<string>('')
const videoElement = ref<HTMLVideoElement | null>(null)

const isLoading = ref(true)
const error = ref<string>('')
const loadingText = ref('Connecting to torrent...')
const progress = ref(0)
const downloadSpeed = ref('')
const torrentName = ref('')

let WebTorrentClient: WebTorrentClient | null = null

onMounted(async () => {
  if (process.client) {
    try {
      // Load WebTorrent from CDN for better browser compatibility
      if (!window.WebTorrent) {
        const script = document.createElement('script')
        script.src = 'https://cdn.jsdelivr.net/npm/webtorrent@latest/webtorrent.min.js'
        script.onload = () => {
          WebTorrentClient = window.WebTorrent
        }
        script.onerror = () => {
          error.value = 'Failed to load WebTorrent from CDN'
        }
        document.head.appendChild(script)
      } else {
        WebTorrentClient = window.WebTorrent
      }
    } catch (err) {
      console.error('Failed to load WebTorrent:', err)
      error.value = 'Failed to load torrent client'
    }
  }
})

watch(() => props.isVisible, (visible) => {
  if (visible && props.magnetUri && WebTorrentClient) {
    initTorrent()
  } else if (!visible) {
    cleanup()
  }
})

onUnmounted(() => {
  cleanup()
})

function initTorrent() {
  if (!WebTorrentClient) {
    error.value = 'WebTorrent client not available'
    return
  }

  cleanup()
  
  if (!props.magnetUri) {
    error.value = 'No magnet URI provided'
    return
  }

  isLoading.value = true
  error.value = ''
  loadingText.value = 'Connecting to torrent...'
  progress.value = 0

  client.value = new WebTorrentClient()
  
  const torrentInstance = client.value.add(props.magnetUri, {
    announce: [
      'wss://tracker.btorrent.xyz',
      'wss://tracker.openwebtorrent.com',
      'wss://tracker.webtorrent.io'
    ]
  })

  torrentInstance.on('metadata', () => {
    torrentName.value = torrentInstance.name
    loadingText.value = 'Loading torrent metadata...'
  })

  torrentInstance.on('ready', () => {
    torrent.value = torrentInstance
    
    const videos = torrentInstance.files.filter(file => 
      file.name.match(/\.(mp4|mkv|avi|mov|webm|m4v)$/i)
    )
    
    videoFiles.value = videos
    
    if (videos.length === 0) {
      error.value = 'No video files found in this torrent'
      return
    }
    
    if (videos.length === 1) {
      selectedFile.value = videos[0]
      selectedFileIndex.value = 0
      loadVideo(videos[0])
    } else {
      isLoading.value = false
      loadingText.value = 'Select a video file to play'
    }
  })

  torrentInstance.on('download', () => {
    if (torrentInstance.length > 0) {
      progress.value = Math.round((torrentInstance.downloaded / torrentInstance.length) * 100)
      downloadSpeed.value = formatSpeed(torrentInstance.downloadSpeed)
    }
  })

  torrentInstance.on('error', (err: Error) => {
    console.error('Torrent error:', err)
    error.value = `Torrent error: ${err.message}`
    isLoading.value = false
  })
}

function selectFile() {
  const index = selectedFileIndex.value as number
  if (index >= 0 && videoFiles.value[index]) {
    selectedFile.value = videoFiles.value[index]
    loadVideo(videoFiles.value[index])
  }
}

function loadVideo(file: TorrentFile) {
  isLoading.value = true
  loadingText.value = `Loading ${file.name}...`
  
  if (!videoElement.value) {
    error.value = 'Video element not found'
    isLoading.value = false
    return
  }
  
  file.renderTo(videoElement.value, {
    autoplay: true,
    controls: true
  }, (err: Error | null) => {
    if (err) {
      error.value = `Failed to load video: ${err.message}`
      isLoading.value = false
      return
    }
    
    isLoading.value = false
  })
}

function onVideoLoadStart() {
  loadingText.value = 'Video loading...'
}

function onVideoCanPlay() {
  isLoading.value = false
}

function onVideoError(event: Event) {
  const target = event.target as HTMLVideoElement
  error.value = `Video playback error: ${target.error?.message || 'Unknown error'}`
  isLoading.value = false
}

function closePlayer() {
  emit('close')
}

function cleanup() {
  if (videoUrl.value) {
    URL.revokeObjectURL(videoUrl.value)
    videoUrl.value = ''
  }
  
  if (client.value) {
    client.value.destroy()
    client.value = null
  }
  
  torrent.value = null
  videoFiles.value = []
  selectedFile.value = null
  selectedFileIndex.value = ''
  isLoading.value = true
  error.value = ''
  progress.value = 0
  downloadSpeed.value = ''
  torrentName.value = ''
}

function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

function formatSpeed(bytesPerSecond: number): string {
  return formatFileSize(bytesPerSecond) + '/s'
}
</script>
